The purpose of this program is to visualise the orbits of linear cellular automata (vectors being repeatedly multiplied by some matrix, mod some modulus). It does so by representing the set of all vectors mod some modulus as coloured squares on a grid. The colours then change for every iteration (every matrix multiplication computed on the vectors) to showcase how the vectors behave under the given setup. To run the program, run orbitvis.py directly. Make sure you have PyGame setup with your Python distribution (PyGame 1.9.6 was used for testing, though other versions should also work).

The right arrow key computes the next iteration and updates the grid. This process can take a long time depending on the automata being visualised. The left arrow key resets to the first iteration (iteration #0) and updates the grid accordingly, OR computes the previous iteration and updates the grid, depending on which CMODE is active (see below).

~~~

There are currently two different colouring modes to use. They can be toggled by setting the COLORMODE variable at the top of orbitvis.py to either 0 or 1.

Mode 0 colours vectors based on which vector they become on a certain iteration. For instance, if the vector <1, 1> becomes <2, 2> on iteration #1--iteration #0 being before any matrix multiplication happens--then the vector <1, 1> will be coloured the same as <2, 2> was on iteration #0.

Mode 1 colours vectors based on which vectors become them on that iteration. For instance, if the vector <1, 1> becomes <2, 2> on iteration #1, then <2, 2> will be coloured the same as <1, 1> was on iteration #0. This mode is slightly problematic when used on automata with transient regions, as multiple vectors can become the same vector during an iteration. The program simply colours vectors based on the last calculated vector that becomes them.

~~~

There are also three different computation modes for traversing orbits. These can be toggled by setting the CMODE variable at the top of orbitvis.py to either 0, 1 or 2.

Mode 0 is used in conjunction with LINCELLAUT, which generates .iteration files. ORBITVIS doesn't perform any automata calculations in this mode. Rather, it merely reads off the data passed to it in the form of .iteration files and displays it. 
This mode is considerably slower than mode 1, especially for higher moduli. However, mode 0 takes less setup to operate. The only thing required to run in mode 0 is the .iteration file which LINCELLAUT generates (using the write_iteration() function).

Mode 1 is also used in conjunction with LINCELLAUT, though the output of the program isn't necessary. Instead of reconstructing the orbits from .iteration files, mode 1 makes use of LINCELLAUT's codebase to generate orbits on the fly. In order to run mode 1, LINCELLAUT's header files, object files, update matrix file, and a shared library file all must be placed in their respective places within ORBITVIS' directory. As well, the modulus used must be manually input into ORBITVIS' .config file (see LINCELLAUT's documentation on .config files for more info).
Despite requiring a fair bit of setup to use, mode 1 is significantly faster than mode 0 thanks to the speed advantage C has over Python. It also requires less disk space to use since the .orbits file doesn't need to be created. 

Mode 2 shares traits with both mode 0 and mode 1. Mode 2 calculates orbits on the fly using C like mode 1, but the vectors' current states are saved each generation like mode 0. This way, only one iteration has to be calculated when incrementing or decrementing iterations. It requires the same prerequisites as mode 1. Also like mode 0, the left arrow button resets to iteration #0.
For large moduli, mode 2 should perform faster than mode 1 at the cost of using more memory to store the current states of each vector. For smaller moduli, mode 2 is probably slower than mode 1 due to the increased time accessing Python lists.

~~~

Mode 0 and mode 2 allow you to gain some insights into the vectors you're looking at. If HOVERMODE is enabled (see documentation for .config file), then clicking on any of the vectors on screen will print out info regarding the vector you clicked, such as which vectors landed on it that iteration, where that vector travelled to that iteration, etc.