The purpose of this program is to visualise the orbits of linear cellular automata (vectors being repeatedly multiplied by some matrix, mod some modulus). It does so by representing the set of all vectors mod some modulus as coloured squares on a grid. The colours then change for every iteration (every matrix multiplication computed on the vectors) to showcase how the vectors behave under the given setup. To run the program, run orbitvis.py directly. Make sure you have PyGame setup with your Python distribution (PyGame 1.9.6 was used for testing, though other versions should also work).

The right arrow key computes the next iteration and updates the grid. This process can take a long time depending on the automata being visualised. The left arrow key resets to the first iteration (iteration #0) and updates the grid accordingly, OR computes the previous iteration and updates the grid, depending on which CMODE is active (see below).

The down arrow key takes a screenshot of the current plane and places it in the working directory.

~~~

There are currently two different colouring modes to use. They can be toggled by setting the COLORMODE variable at the top of orbitvis.py to either 0 or 1.

Mode 0 colours vectors based on which vector they become on a certain iteration. For instance, if the vector <1, 1> becomes <2, 2> on iteration #1--iteration #0 being before any matrix multiplication happens--then the vector <1, 1> will be coloured the same as <2, 2> was on iteration #0.

Mode 1 colours vectors based on which vectors become them on that iteration. For instance, if the vector <1, 1> becomes <2, 2> on iteration #1, then <2, 2> will be coloured the same as <1, 1> was on iteration #0. This mode is slightly problematic when used on automata with transient regions, as multiple vectors can become the same vector during an iteration. The program simply colours vectors based on the last calculated vector that becomes them.

~~~

There are also two different computation modes for traversing orbits. These can be toggled by setting the CMODE variable at the top of orbitvis.py to either 1 or 2.

Mode 1 makes use of LINCELLAUT's codebase to generate orbits on the fly. In order to run mode 1, LINCELLAUT's header files, object files, update matrix file, and a shared library file all must be placed in their respective places within ORBITVIS' directory. As well, the modulus used must be manually input into ORBITVIS' .config file (see LINCELLAUT's documentation on .config files for more info).

Mode 2 calculates orbits on the fly using C like mode 1, but the vectors' current states are saved each generation. This way, only one iteration has to be calculated when incrementing or decrementing iterations. It requires the same prerequisites as mode 1. The left arrow button resets to iteration #0.
For large moduli, mode 2 should perform faster than mode 1 at the cost of using more memory to store the current states of each vector. For smaller moduli, mode 2 is probably slower than mode 1 due to the increased time accessing Python lists.

~~~

Mode 2 allows you to gain some insights into the vectors you're looking at. If HOVERMODE is enabled (see documentation for .config file), then clicking on any of the vectors on screen will print out info regarding the vector you clicked, such as which vectors landed on it that iteration, where that vector travelled to that iteration, etc.

~~~

If CAPTUREMODE is enabled (see documentation for .config file), ORBITVIS will generate every possible plane with the given settings and save them as screenshots. ORBITVIS knows to automatically stop generating screenshots when the vectors return to their initial state. HOWEVER, ORBITVIS makes no attempt to stop taking screenshots if it gets stuck in a cycle that does not reset the plane back to its initial configuration. It is the user's responsibility to set the MAXCAPTURES variable (via the .config file) to cap the number of desired screenshots in this case.